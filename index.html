<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Nexus HTTP/3: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Nexus HTTP/3
   </div>
   <div id="projectbrief">A QUIC and HTTP/3 library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_TUTORIAL"></a> Nexus provides two sets of interfaces: one in <code>namespace <a class="el" href="namespacenexus_1_1quic.html" title="Generic QUIC library.">nexus::quic</a></code> for generic QUIC clients and servers, and another in <code>namespace <a class="el" href="namespacenexus_1_1h3.html" title="HTTP/3 library.">nexus::h3</a></code> for HTTP/3 clients and servers.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Global Initialization</h1>
<p>The library must be initialized before use, and this is accomplished by creating a <code><a class="el" href="classnexus_1_1global_1_1context.html" title="a context object representing the global initialization of the nexus QUIC/HTTP library,...">nexus::global::context</a></code> with one of its factory functions: </p><pre class="fragment">{
  auto global = nexus::global::init_client();
  ...
} // global cleanup on destruction
</pre><h1><a class="anchor" id="autotoc_md2"></a>
TLS</h1>
<p>All QUIC connections are secure by default, so the use of TLS is not optional. TLS configuration is left to the application, which is expected to provide an initialized <code>asio::ssl::context</code> to the client and server interfaces.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
TLS v1.3</h2>
<p>QUIC requires TLS version 1.3, so the ssl context should be initialized with a TLS 1.3 method, and its min/max protocol version should be set: </p><pre class="fragment">auto ssl = asio::ssl::context{asio::ssl::context::tlsv13};
SSL_CTX_set_min_proto_version(ssl.native_handle(), TLS1_3_VERSION);
SSL_CTX_set_max_proto_version(ssl.native_handle(), TLS1_3_VERSION);
</pre><h2><a class="anchor" id="autotoc_md4"></a>
Certificate Verification</h2>
<p>All QUIC clients <a href="https://www.rfc-editor.org/rfc/rfc9001.html#name-peer-authentication">"MUST authenticate the identity of the server"</a>, and the application is responsible for providing an SSL context that does this: </p><pre class="fragment">ssl.set_verify_mode(asio::ssl::verify_peer);
</pre><h1><a class="anchor" id="autotoc_md5"></a>
QUIC</h1>
<h2><a class="anchor" id="autotoc_md6"></a>
Application-Layer Protocol Negotiation</h2>
<p>QUIC endpoints use a TLS extension called <a href="https://en.wikipedia.org/wiki/ALPN">Application-Layer Protocol Negotiation</a> (ALPN) to negotiate the application protocol. The HTTP/3 client and server automatically negotiate the "h3" protocol, but the generic QUIC client and server are protocol-agnostic so must negotiate this manually.</p>
<p>The client provides its desired protocol names in a call to <code>SSL_CTX_set_alpn_protos()</code>.</p>
<p>The server implements this negotiation using <code>SSL_CTX_set_alpn_select_cb()</code> and <code>SSL_select_next_proto()</code>, either selecting the first supported protocol in the client's list, or rejecting the client's handshake.</p>
<p>The negotiated protocol can be queried on either side with <code>SSL_get0_alpn_selected()</code>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Settings</h2>
<p>As part of the connection handshake, the client and server exchange their QUIC <a href="https://www.rfc-editor.org/rfc/rfc9000.html#transport-parameter-definitions">Transport Parameters</a>. Some of the transport parameters we send, such as flow control limits and timeouts, can be configured with <code>class <a class="el" href="structnexus_1_1quic_1_1settings.html" title="quic transport settings used to initialize a client or server">nexus::quic::settings</a></code>.</p>
<p>Nexus also receives the peer's transport parameters, and will automatically respect the limits they impose. For example, once we've opened the maximum number of outgoing streams on the connection, requests to initiate a new outgoing stream will block until another stream closes. And once we reach a stream or connection flow control limit, requests to write more data will block until the peer reads some and adjusts the window.</p>
<p>The client and server constructors take an optional <code><a class="el" href="structnexus_1_1quic_1_1settings.html" title="quic transport settings used to initialize a client or server">nexus::quic::settings</a></code> argument and, once constructed, these settings cannot be changed.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
Client</h2>
<p>The generic QUIC client (<code>class <a class="el" href="classnexus_1_1quic_1_1client.html" title="a generic QUIC client that owns a UDP socket and uses it to service client connections">nexus::quic::client</a></code>) takes control of a bound <code>asio::ip::udp::socket</code> and <code>asio::ssl::context</code> to initiate secure connections (<code>class <a class="el" href="classnexus_1_1quic_1_1connection.html" title="a generic QUIC connection that can initiate outgoing streams and accept incoming streams">nexus::quic::connection</a></code>) to QUIC servers. </p><pre class="fragment">auto client = nexus::quic::client{ex, bind_endpoint, ssl};
</pre><p>Initiating a client connection is instantaneous, and does not wait for the connection handshake to complete. This allows the application to start opening streams and staging data in the meantime. If the handshake does fail, the relevant error code will be delivered to any pending stream operations.</p>
<p>A client initiates a connection either by calling <code><a class="el" href="classnexus_1_1quic_1_1client.html#a2e75d86d4a030cb926b53c7a97f175a3" title="open a connection to the given remote endpoint and hostname. this initiates the TLS handshake,...">nexus::quic::client::connect()</a></code>: </p><pre class="fragment">auto conn = nexus::quic::connection{client};
client.connect(conn, endpoint, hostname);
</pre><p>Or by providing the remote endpoint and hostname arguments to the <code><a class="el" href="classnexus_1_1quic_1_1connection.html" title="a generic QUIC connection that can initiate outgoing streams and accept incoming streams">nexus::quic::connection</a></code> constructor: </p><pre class="fragment">auto conn = nexus::quic::connection{client, endpoint, hostname};
</pre><h2><a class="anchor" id="autotoc_md9"></a>
Server</h2>
<p>The generic QUIC server (<code>class <a class="el" href="classnexus_1_1quic_1_1server.html" title="a generic QUIC server capable of managing one or more UDP sockets via class acceptor">nexus::quic::server</a></code>) listens on one or more UDP sockets (using <code>class <a class="el" href="classnexus_1_1quic_1_1acceptor.html" title="a generic QUIC acceptor that owns a UDP socket and uses it to accept and service incoming connections">nexus::quic::acceptor</a></code>) to accept secure connections from QUIC clients. </p><pre class="fragment">auto server = nexus::quic::server{ex};
auto acceptor = nexus::quic::acceptor{server, bind_endpoint, ssl};
acceptor.listen(16);

auto conn = nexus::quic::connection{acceptor};
acceptor.accept(conn);
</pre><p>Unlike <code><a class="el" href="classnexus_1_1quic_1_1client.html#a2e75d86d4a030cb926b53c7a97f175a3" title="open a connection to the given remote endpoint and hostname. this initiates the TLS handshake,...">nexus::quic::client::connect()</a></code> which returns immediately without waiting for the connection handshake, <code><a class="el" href="classnexus_1_1quic_1_1acceptor.html#a276bb5adfade5db7aa15bdae73c5c865" title="accept an incoming connection whose TLS handshake has completed successfully">nexus::quic::acceptor::accept()</a></code> only completes once the handshake is successful.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Connection</h2>
<p>Once a generic QUIC connection (<code>class <a class="el" href="classnexus_1_1quic_1_1connection.html" title="a generic QUIC connection that can initiate outgoing streams and accept incoming streams">nexus::quic::connection</a></code>) has been connected or accepted, it can be used both to initiate outgoing streams with <code><a class="el" href="classnexus_1_1quic_1_1connection.html#a46680c193cf48a4f776491bd9286f511" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">nexus::quic::connection::connect()</a></code>: </p><pre class="fragment">auto stream = nexus::quic::stream stream{conn};
conn.connect(stream);
</pre><p>And to accept() incoming streams: </p><pre class="fragment">auto stream = nexus::quic::stream stream{conn};
conn.accept(stream);
</pre><p>When a connection closes, all related streams are closed and any pending operations are canceled with a connection error.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Stream</h2>
<p>Once a generic QUIC stream (<code>class <a class="el" href="classnexus_1_1quic_1_1stream.html" title="a generic bidirectional QUIC stream that meets the type requirements of asio&#39;s AsyncRead/WriteStream ...">nexus::quic::stream</a></code>) has been connected or accepted, it provides bidirectional, reliable ordered delivery of data.</p>
<p>For reads and writes, <code><a class="el" href="classnexus_1_1quic_1_1stream.html" title="a generic bidirectional QUIC stream that meets the type requirements of asio&#39;s AsyncRead/WriteStream ...">nexus::quic::stream</a></code> models the asio concepts <code>AsyncReadStream</code>, <code>AsyncWriteStream</code>, <code>SyncReadStream</code> and <code>SyncWriteStream</code>, so can be used with the same read and write algorithms as <code>asio::ip::tcp::socket</code>: </p><pre class="fragment">char request[16]; // read 16 bytes from the stream
auto bytes = asio::read(stream, asio::buffer(data));
</pre><p>The stream can be closed in one or both directions with <code><a class="el" href="classnexus_1_1quic_1_1stream.html#aef1e003616a961e0c60ff80ed1b67cac" title="shut down a stream for reads (0), writes (1), or both (2). shutting down the read side will cancel an...">nexus::quic::stream::shutdown()</a></code> and <code><a class="el" href="classnexus_1_1quic_1_1stream.html#a07ff93f517e5d0baa5f6e0ff25128feb" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">nexus::quic::stream::close()</a></code>.</p>
<p>Writes may be buffered by the stream due to a preference to send full packets, similar to Nagle's algorithm for TCP. Buffered stream data can be flushed, either by calling <code><a class="el" href="classnexus_1_1quic_1_1stream.html#a072931593deae276645944bddc3a5832" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">nexus::quic::stream::flush()</a></code> manually, shutting down the stream for write, or closing the stream.</p>
<p>Graceful shutdown of a QUIC stream differs from normal TCP sockets, which can be closed immediately even if there is unsent or unacked data, and the kernel will continue to (re)transmit data in the background until everything is acked. Because this transmission in QUIC depends on an open connection, the application must not close the associated <code><a class="el" href="classnexus_1_1quic_1_1connection.html" title="a generic QUIC connection that can initiate outgoing streams and accept incoming streams">nexus::quic::connection</a></code> until the stream shutdown completes. To support this graceful shutdown, the behavior of <code><a class="el" href="classnexus_1_1quic_1_1stream.html#a07ff93f517e5d0baa5f6e0ff25128feb" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">nexus::quic::stream::close()</a></code> matches that of the socket option <code>SO_LINGER</code>, where the close does not complete until all stream data has been successfully acked. <code><a class="el" href="classnexus_1_1quic_1_1stream.html#a6319d8ab5a8c1fc0c976333fe58964ef" title="close the stream gracefully, blocking until all written data is acknowledged by the peer....">nexus::quic::stream::async_close()</a></code> is provided for asynchronous graceful shutdown.</p>
<p>A separate function <code><a class="el" href="classnexus_1_1quic_1_1stream.html#ac3deb3777ddf26e824a42b0f016821c5" title="reset the stream immediately in both directions, canceling any pending operations and discarding any ...">nexus::quic::stream::reset()</a></code> is provided for immediate shutdown, and the <code><a class="el" href="classnexus_1_1quic_1_1stream.html#a60e5740c05db32076c96117307dd7a86" title="reset the stream on destruction">nexus::quic::stream::~stream()</a></code> destructor calls <code><a class="el" href="classnexus_1_1quic_1_1stream.html#ac3deb3777ddf26e824a42b0f016821c5" title="reset the stream immediately in both directions, canceling any pending operations and discarding any ...">nexus::quic::stream::reset()</a></code> instead of <code><a class="el" href="classnexus_1_1quic_1_1stream.html#a07ff93f517e5d0baa5f6e0ff25128feb" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">nexus::quic::stream::close()</a></code>.</p>
<h1><a class="anchor" id="autotoc_md12"></a>
Synchronous and Asynchronous</h1>
<p>For each potentially-blocking operation, both a synchronous or asynchronous version of the function are provided. The asynchronous function names all begin with <code>async_</code>, and attempt to meet all "Requirements on asynchronous operations" specified by asio.</p>
<p>However, QUIC requires that we regularly poll its sockets for incoming packets, respond with acknowledgements and other control messages, and resend unacknowledged packets. The Nexus client and server classes issue asynchronous operations for this background work, and expect their associated execution context to process those operations in a timely manner - for example, by calling <code>asio::io_context::run()</code>.</p>
<p>This is unlike the asio I/O objects you may be familiar with, which can be used exclusively in the synchronous blocking mode without requiring another thread to process asynchronous work.</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Exceptions</h1>
<p>The library should be useable with or without exceptions, so both a throwing and non-throwing version of each function is provided. Their signatures are the same, except the non-throwing version takes a mutable reference to error_code as an additional parameter.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Thread Safety</h1>
<p>Global init/shutdown is not thread-safe with respect to other classes.</p>
<p>All engine operations can be considered thread-safe. The lsquic engine instance is not re-entrant, so an engine-wide mutex is used to serialize access to the engine and its related state. This mutex is held over all calls into the lsquic engine, including its calls to the callback functions we provide. No blocking system calls are made under this mutex, as lsquic does no i/o of its own. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20
</small></address>
</body>
</html>
